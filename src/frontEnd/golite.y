/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{


#include <stdio.h>
#include <stdlib.h>
#include "tree.h"

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}


/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	int intval;
	char *identifier;
    float floatval;
    char *stringval;
    int boolval;
    char runeval;

    NType *typeval;
    NExpression *exp;
    NStatement *stmt;
    NDeclaration *dec;
    NFunction *func;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */
%type <progval> program
%type <func> funcdec 
%type <dec> topdecl dec typedec vardec parameters parameter
%type <stmt> stmts stmt printstmt ifstmt elsestmt switchstmt switchbody forstmt simplestmt returnstmt 
%type <exp> exp exps idents
%type <typeval> type opttype

%token <identifier> tIDENTIFIER
%token <intval> tINTLITERAL
%token <floatval> tFLOATLITERAL
%token <boolval> tBOOLLITERAL
%token <runeval> tRUNELITERAL
%token <stringval> tSTRINGLITERAL
// %token <stringval> tRAWSTRINGLITERAL //not supported in golite_mini

%token tBREAK
%token tCASE
%token tCONST
%token tCHAN
%token tCONTINUE
%token tDEFAULT
%token tDEFER
%token tELSE
%token tFALLTHROUGH
%token tFOR
%token tFUNC
%token tGO
%token tGOTO
%token tIF
%token tIMPORT
%token tINTERFACE
%token tMAP
%token tPACKAGE
%token tRANGE
%token tRETURN
%token tSELECT
%token <identifier> tSTRUCT //not supported in golite_mini
%token tSWITCH
%token tTYPE
%token tVAR
%token tPRINT
%token tPRINTLN
%token tAPPEND //not supported in golite_mini
%token tLEN
%token tCAP
%token tPLUS
%token tMINUS
%token tDIV
%token tMULT
%token tMOD
%token tBWAND
%token tBWOR
%token tBWXOR
%token tRIGHTSHIFT
%token tLEFTSHIFT
%token tBWANDNOT
%token tPLUSASSIGN
%token tMINUSASSIGN
%token tMULTASSIGN
%token tDIVASSIGN
%token tMODASSIGN
%token tBWANDASSIGN
%token tBWORASSIGN
%token tBWXORASSIGN
%token tRSHIFTASSIGN
%token tLSHIFTASSIGN
%token tBWANDNOTASSIGN
%token tAND
%token tOR
%token tARROW
%token tINCREMENT
%token tDECREMENT
%token tEQUAL
%token tLESS
%token tGREATER
%token tASSIGN
%token tNOT
%token tNOTEQ
%token tLESSEQ
%token tGREATEREQ
%token tCOLONASSIGN //not supported in golite_mini
%token tELLIPSIS
%token tLBRACE
%token tLPAREN
%token tLBRACKET
%token tCOMMA
%token tPERIOD
%token tRBRACE
%token tRPAREN
%token tRBRACKET
%token tSEMICOLON
%token tCOLON
%token tNEWLINE


/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */



%left tOR
%left tAND tANDNOT
%left tBWOR tBWXOR
%left tBWAND
%left tLEFTSHIFT tRIGHTSHIFT
%left tEQ tNEQ 
%left tGEQ tLEQ tGREATER tLESS
%left tPLUS tMINUS
%left tMULT tDIV tMOD 
%left UNARY
%left tPERIOD // struct field access
%left tLBRACKET
%left tLBRACE

/* Unused tokens, only for precedence directives */
%token UNARY 

/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose


/* For making the AST constructor work */
%code requires
{
	#include "tree.h"
}

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%% 

/* Represents the entire program. Makes sure there is only one package dec */
program           : tPACKAGE tIDENTIFIER tSEMICOLON topdecl 
                ;

topdecl         : %empty
                | dec topdecl 
                | funcdec topdecl
                ;

literalexp      : tINTLITERAL {$$ = new NExpLiteral($1);}
                | tFLOATLITERAL {$$ = new NExpLiteral($1);}
                | tBOOLLITERAL {$$ = new NExpLiteral($1);}}
                | tRUNELITERAL {$$ = new NExpLiteral($1);}
                | tSTRINGLITERAL {$$ = new NExpLiteral($1);}
                ;

unaryexp        : tPLUS exp %prec UNARY {$$ = new NExpUnary(*$2, posExp);}
                | tMINUS exp %prec UNARY {$$ = new NExpUnary(*$2, negExp);}
                | tNOT exp %prec UNARY {$$ = new NExpUnary(*$2, notExp);}
                | tBWXOR exp %prec UNARY {$$ = new NExpUnary(*$2, xorExp);}
                | tLBRACE exp tRBRACE {$$ = new NExpUnary(*$2, parenExp);}
                ;

binaryexp       : exp tLESS exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tGREATER exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tEQ exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tNEQ exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tGEQ exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tLEQ exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tAND exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tOR exp  {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tPLUS exp  {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tMINUS exp  {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tBWOR exp  {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tBWXOR exp  {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tMULT exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tDIV exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tMOD exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tLEFTSHIFT exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tRIGHTSHIFT exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tBWAND exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                | exp tANDNOT exp {$$ = new NExpBinary(*$1, *$3, plusExp);}
                ;

builtinexp      : tLEN tLBRACE exp tRBRACE {$$ = new NExpBuiltin(*$3, lenExp);}
                | tCAP tLBRACE exp tRBRACE {$$ = new NExpBuiltin(*$3, capExp);}
                ;

/* Expressions of all kinds. */
exp             : tIDENTIFIER {$$ = new NExpIdentifier(string($1)); }
                | literalexp
                | unaryexp
                | binaryexp
                | builtinexp
                | tIDENTIFIER tLBRACKET exp tRBRACKET {$$ = new NExpIndexer($1, $3);}
                | tIDENTIFIER tLBRACE exps tRBRACE { $$ = new NExpFuncCall($1, $3); }  
                | tIDENTIFIER tLBRACE tRBRACE { $$ = new NExpFuncCall($1, $3); }  
                ;

/* TODO weed for no exp for case, assign(stmt and decl),*/
exps            : exp
                | exp tCOMMA exps
                ;                

idents          : idents tCOMMA tIDENTIFIER %prec UNARY
                | tIDENTIFIER tCOMMA tIDENTIFIER 
                ;

/* variable declarations */
dec             : tVAR vardec {$$ = $2;}
                | tTYPE tIDENTIFIER type tSEMICOLON {$$ = $1;}
                ;

vardec          : idents type tSEMICOLON 
                | idents opttype tASSIGN exps tSEMICOLON 
                | tIDENTIFIER type tSEMICOLON 
                | tIDENTIFIER opttype tASSIGN exp tSEMICOLON
                ;

/* function definitions */
funcdec         : tFUNC tIDENTIFIER tLBRACE parameters tRBRACE opttype tLPAREN stmts tRPAREN tSEMICOLON
		        |  tFUNC tIDENTIFIER tLBRACE tRBRACE opttype tLPAREN stmts tRPAREN tSEMICOLON 
                ;


/* List of parameters of function declaration signatures */
parameters      : parameter { $$ = new ParamList(); $$.push_back($1)}
                | parameter tCOMMA parameters
                ;

opttype         : %empty
                | type {$$ = $1;}
                ;

type            : tIDENTIFIER 
                | tLBRACKET tRBRACKET type 
                | tLBRACKET tINTLITERAL tRBRACKET type 
                | tLBRACE type tRBRACE 
                ;

stmts           : %empty 
                | stmts stmt 
                ;

/* TODO weeder for break, continue, return*/
stmt            : 
                | tBREAK tSEMICOLON 
                | tCONTINUE tSEMICOLON 
                | tLPAREN stmts tRPAREN tSEMICOLON
                | ifstmt {$$ = $1;}
                | switchstmt {$$ = $1;}
                | forstmt {$$ = $1;}
                | returnstmt {$$ = $1;}
                | dec 
                | tSEMICOLON 
                | simplestmt
                ;

printstmt       : tPRINT tLBRACE exps tRBRACE tSEMICOLON
                | tPRINTLN tLBRACE exps tRBRACE tSEMICOLON 
				| tPRINT tLPAREN tRBRACE tSEMICOLON 
				| tPRINTLN tLPAREN tRBRACE
                ;

ifstmt          : tIF exp tLPAREN stmts tRPAREN elsestmt 
                | tIF tSEMICOLON exp tLPAREN stmts tRPAREN elsestmt 
                ;

elsestmt        : tELSE tIF exp tLPAREN stmts tRPAREN elsestmt
                | tELSE tIF tSEMICOLON exp tLPAREN stmts tRPAREN elsestmt 
                | tELSE tLPAREN stmts tRPAREN tSEMICOLON 
                | tSEMICOLON {$$ = NULL;}
                ;

/* Defines switch statements */
switchstmt      : tSWITCH tLPAREN switchbody tRPAREN tSEMICOLON
                | tSWITCH exp tLPAREN switchbody tRPAREN tSEMICOLON 
                ;

/* Defines the body of a switch statement Handling expression list as cases?*/
switchbody      : switchbody tCASE exps tCOLON stmts 
                | switchbody tDEFAULT tCOLON stmts 
                | %empty {$$ = NULL;}
                ;

simplestmt      : %empty
                | tIDENTIFIER tINCREMENT
                | tIDENTIFIER tDECREMENT  
                | exps tASSIGN exps
                ;

/* Defines all three supported kinds of support statements */
forstmt         : tFOR tLPAREN stmts tRPAREN tSEMICOLON 
                | tFOR exp tLPAREN stmts tRPAREN tSEMICOLON 
                | tFOR simplestmt tSEMICOLON exp tSEMICOLON simplestmt tLPAREN stmts tRPAREN tSEMICOLON 
                | tFOR simplestmt tSEMICOLON tSEMICOLON simplestmt tLPAREN stmts tRPAREN tSEMICOLON 
                ;

/* Defines return statements */
returnstmt      : tRETURN tSEMICOLON 
                | tRETURN exp tSEMICOLON 
                ;